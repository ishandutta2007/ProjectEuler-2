#------------------------------------------------- Cyclical figurate numbers ------------------------------------------ #
#                                                                                                                       #
#       Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal)         #
#       numbers and are generated by the following formulae:                                                            #
#                                                                                                                       #
#       Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...                                            #
#       Square	 	        P4,n=n2	 	        1, 4, 9, 16, 25, ...                                            #
#       Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...                                           #
#       Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...                                           #
#       Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...                                           #
#       Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...                                           #
#                                                                                                                       #
#       The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.                   #                                                                                                                #
#           1) The set is cyclic, in that the last two digits of each number is the first two digits of the next number #
#           (including the last number with the first).                                                                 #
#           2) Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882),           #
#           is represented by a different number in the set.                                                            #
#           3) This is the only set of 4-digit numbers with this property.                                              #
#                                                                                                                       #
#       Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:               #
#       triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number        #
#       in the set.                                                                                                     #
# --------------------------------------------------------------------------------------------------------------------- #
import time
import math

def genTriangleNumbers(bot, top):
    n0 = math.ceil((-1 + math.ceil(math.sqrt(1 + 8 * bot))) / 2)
    n1 = math.floor((-1 + math.sqrt(1 + 8 * top)) / 2)
    
    genTriangleNumbers.NUMBERS = [0] * (n1 - n0 + 1)
    for i in range(n0, n1 + 1):
        genTriangleNumbers.NUMBERS[i - n0] = i * (i + 1) // 2

    for t in genTriangleNumbers.NUMBERS:
        if (t // 100 not in genTriangleNumbers.D):
            genTriangleNumbers.D[t // 100] = [t % 100]
        else:
            genTriangleNumbers.D[t // 100].append(t % 100)
            
    return genTriangleNumbers.NUMBERS
genTriangleNumbers.NUMBERS = []
genTriangleNumbers.D = { }

def genSquareNumbers(bot, top):
    n0 = math.ceil(math.sqrt(bot))
    n1 = math.floor(math.sqrt(top))
    
    genSquareNumbers.NUMBERS = [0] * (n1 - n0 + 1)
    for i in range(n0, n1 + 1):
        genSquareNumbers.NUMBERS[i - n0] = i * i

    for s in genSquareNumbers.NUMBERS:
        if (s // 100 not in genSquareNumbers.D):
            genSquareNumbers.D[s // 100] = [s % 100]
        else:
            genSquareNumbers.D[s // 100].append(s % 100)
            
    return genSquareNumbers.NUMBERS
genSquareNumbers.NUMBERS = []
genSquareNumbers.D = { }

def genPentagonalNumbers(bot, top):
    n0 = math.ceil((1 + math.ceil(math.sqrt(1 + 24 * bot))) / 6)
    n1 = math.floor((1 + math.sqrt(1 + 24 * top)) / 6)
    
    genPentagonalNumbers.NUMBERS = [0] * (n1 - n0 + 1)
    for i in range(n0, n1 + 1):
        genPentagonalNumbers.NUMBERS[i - n0] = i * (3 * i - 1) // 2

    for p in genPentagonalNumbers.NUMBERS:
        if (p // 100 not in genPentagonalNumbers.D):
            genPentagonalNumbers.D[p // 100] = [p % 100]
        else:
            genPentagonalNumbers.D[p // 100].append(p % 100)
            
    return genPentagonalNumbers.NUMBERS
genPentagonalNumbers.NUMBERS = []
genPentagonalNumbers.D = { }

def genHexagonalNumbers(bot, top):
    n0 = math.ceil((1 + math.ceil(math.sqrt(1 + 16 * bot))) / 4)
    n1 = math.floor((1 + math.sqrt(1 + 16 * top)) / 4)
    
    genHexagonalNumbers.NUMBERS = [0] * (n1 - n0 + 1)
    for i in range(n0, n1 + 1):
        genHexagonalNumbers.NUMBERS[i - n0] = i * (2 * i - 1)

    for h in genHexagonalNumbers.NUMBERS:
        if (h // 100 not in genHexagonalNumbers.D):
            genHexagonalNumbers.D[h // 100] = [h % 100]
        else:
            genHexagonalNumbers.D[h // 100].append(h % 100)
            
    return genHexagonalNumbers.NUMBERS
genHexagonalNumbers.NUMBERS = []
genHexagonalNumbers.D = { }

def genHeptagonlNumbers(bot, top):
    n0 = math.ceil((3 + math.ceil(math.sqrt(9 + 40 * bot))) / 10)
    n1 = math.floor((3 + math.sqrt(9 + 40 * top)) / 10)
    
    genHeptagonlNumbers.NUMBERS = [0] * (n1 - n0 + 1)
    for i in range(n0, n1 + 1):
        genHeptagonlNumbers.NUMBERS[i - n0] = i * (5 * i - 3) // 2

    for h in genHeptagonlNumbers.NUMBERS:
        if (h // 100 not in genHeptagonlNumbers.D):
            genHeptagonlNumbers.D[h // 100] = [h % 100]
        else:
            genHeptagonlNumbers.D[h // 100].append(h % 100)
            
    return genHeptagonlNumbers.NUMBERS
genHeptagonlNumbers.NUMBERS = []
genHeptagonlNumbers.D = { }

def genOctagonlNumbers(bot, top):
    n0 = math.ceil((2 + math.ceil(math.sqrt(4 + 12 * bot))) / 6)
    n1 = math.floor((2 + math.sqrt(4 + 12 * top)) / 6)
    
    genOctagonlNumbers.NUMBERS = [0] * (n1 - n0 + 1)
    for i in range(n0, n1 + 1):
        genOctagonlNumbers.NUMBERS[i - n0] = i * (3 * i - 2)

    for o in genOctagonlNumbers.NUMBERS:
        if (o // 100 not in genOctagonlNumbers.D):
            genOctagonlNumbers.D[o // 100] = [o % 100]
        else:
            genOctagonlNumbers.D[o // 100].append(o % 100)
            
    return genOctagonlNumbers.NUMBERS
genOctagonlNumbers.NUMBERS = []
genOctagonlNumbers.D = { }

def matchFigurals(ss, start, sets, sol):
    if (sets == [] and start == ss):
        # print (sol)
        matchFigurals.SOL = sol
        return start

    if (3 in sets):
        if (start in genTriangleNumbers.D):
            new_sets = sets[:]
            new_sets.remove(3)
            for t in genTriangleNumbers.D[start]:
                new_sol = sol[:]
                new_sol.append((start * 100 + t, "tri"))
                r = matchFigurals(ss, t, new_sets, new_sol)
                if (r != -1):
                    return r
    if (4 in sets):
        if (start in genSquareNumbers.D):
            new_sets = sets[:]
            new_sets.remove(4)
            for t in genSquareNumbers.D[start]:
                new_sol = sol[:]
                new_sol.append((start * 100 + t, "squ"))
                r = matchFigurals(ss, t, new_sets, new_sol)
                if (r != -1):
                    return r

    if (5 in sets):
        if (start in genPentagonalNumbers.D):
            new_sets = sets[:]
            new_sets.remove(5)
            for t in genPentagonalNumbers.D[start]:
                new_sol = sol[:]
                new_sol.append((start * 100 + t, "pen"))
                r = matchFigurals(ss, t, new_sets, new_sol)
                if (r != -1):
                    return r

    if (6 in sets):
        if (start in genHexagonalNumbers.D):
            new_sets = sets[:]
            new_sets.remove(6)
            for t in genHexagonalNumbers.D[start]:
                new_sol = sol[:]
                new_sol.append((start * 100 + t, "hex"))
                r = matchFigurals(ss, t, new_sets, new_sol)
                if (r != -1):
                    return r

    if (7 in sets):
        if (start in genHeptagonlNumbers.D):
            new_sets = sets[:]
            new_sets.remove(7)
            for t in genHeptagonlNumbers.D[start]:
                new_sol = sol[:]
                new_sol.append((start * 100 + t, "hep"))
                r = matchFigurals(ss, t, new_sets, new_sol)
                if (r != -1):
                    return r

    return -1
matchFigurals.SOL = []
    
def eu61():
    BOT = 1000
    TOP = 9999

    genTriangleNumbers(BOT, TOP)
    genSquareNumbers(BOT, TOP)
    genPentagonalNumbers(BOT, TOP)
    genHexagonalNumbers(BOT, TOP)
    genHeptagonlNumbers(BOT, TOP)
    genOctagonlNumbers(BOT, TOP)

    for o in genOctagonlNumbers.D:
        for end in genOctagonlNumbers.D[o]:
            if (matchFigurals(o, end, [3, 4, 5, 6, 7], [(o * 100 + end, "oct")]) == o):
                s = 0
                for f in matchFigurals.SOL:
                    s += f[0]
                    
                return s

if __name__ == "__main__":
    startTime = time.clock()
    print (eu61())
    elapsedTime = time.clock() - startTime
    print ("Time spent in (", __name__, ") is: ", elapsedTime, " sec")
